#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEScan.h>
#include <BLEAdvertisedDevice.h>
#include <FastLED.h>

// --- 1. HARDWARE SETTINGS ---
#define LED_PIN     4
#define NUM_LEDS    144
#define BRIGHTNESS  100
#define LED_TYPE    WS2812B
#define COLOR_ORDER GRB
CRGB leds[NUM_LEDS];

// --- 2. TIMING & FLAGS (From your Heartbeat script) ---
#define SCAN_TIME 60
#define RETRY_DELAY 5000 // 5 second delay before re-scanning

static BLEAddress pedalAddress("e8:83:38:c5:03:c0");
static BLEUUID serviceUUID("1818"); 
static BLEUUID charUUID("2A63");    

static boolean doConnect = false;
static boolean connected = false;
static boolean doScan = true;
static BLERemoteCharacteristic* pRemoteCharacteristic;
static BLEAddress* pServerAddress = nullptr;

// --- 3. DATA VARIABLES ---
int totalPower = 0;
float leftPercent = 50.0;
float smoothedPos = 72.0;

// --- 4. CALLBACKS (From Heartbeat script) ---
class MyClientCallback : public BLEClientCallbacks {
  void onConnect(BLEClient* pclient) {
    connected = true;
    doScan = false;
    Serial.println("Connected to Assioma");
  }

  void onDisconnect(BLEClient* pclient) {
    connected = false;
    doScan = true;
    Serial.println("Disconnected from Assioma");
  }
};

static void notifyCallback(BLERemoteCharacteristic* pChar, uint8_t* pData, size_t length, bool isNotify) {
  if (length >= 4) {
    totalPower = pData[2] | (pData[3] << 8);
    if (length >= 5) {
      leftPercent = pData[4] / 2.0;
    }
  }
}

class MyAdvertisedDeviceCallbacks : public BLEAdvertisedDeviceCallbacks {
  void onResult(BLEAdvertisedDevice advertisedDevice) {
    if (advertisedDevice.getAddress().equals(pedalAddress)) {
      advertisedDevice.getScan()->stop();
      pServerAddress = new BLEAddress(advertisedDevice.getAddress());
      doConnect = true;
      doScan = false;
    }
  }
};

// --- 5. LED VISUAL LOGIC ---
void updateLEDs() {
  FastLED.clear();
  int middle = NUM_LEDS / 2;
  leds[middle-1] = leds[middle] = leds[middle+1] = CRGB(0, 0, 30); 

  if (connected && totalPower == 0) {
    int fillAmount = 36; 
    int startIdx = middle - (fillAmount / 2);
    for(int i = startIdx; i < startIdx + fillAmount; i++) {
      leds[i] = CRGB(40, 40, 40); 
    }
    return;
  }

  int windowSize = 25; 
  float diff = abs(50.0 - leftPercent);
  
  CRGB color;
  if (diff <= 1.0)      color = CRGB::Blue;   
  else if (diff <= 2.5) color = CRGB::Green;  
  else if (diff <= 4.5) color = CRGB::Yellow; 
  else                  color = CRGB::Red;    

  // Direction: Higher Left% = Lower LED Index (Moved to the left)
  float targetPos = map(leftPercent * 10.0, 600.0, 400.0, (windowSize/2), NUM_LEDS - (windowSize/2));
  targetPos = constrain(targetPos, (windowSize/2), NUM_LEDS - (windowSize/2));

  smoothedPos = smoothedPos + (targetPos - smoothedPos) * 0.12;

  int startIdx = (int)smoothedPos - (windowSize / 2);
  for(int i = 0; i < windowSize; i++) {
    int currentLed = startIdx + i;
    if(currentLed >= 0 && currentLed < NUM_LEDS) {
      leds[currentLed] = color;
    }
  }
}

// --- 6. INITIAL SETUP ---
void setup() {
  Serial.begin(115200);
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(BRIGHTNESS);
  
  // Rainbow Startup
  for(int i = 0; i < NUM_LEDS; i++) {
    leds[i] = CHSV(i * 2, 255, 100);
    FastLED.show();
    delay(2);
  }
  FastLED.clear(true);

  BLEDevice::init("ESP32_Balance_Pro");
  BLEScan* pBLEScan = BLEDevice::getScan();
  pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
  pBLEScan->setActiveScan(true);
  pBLEScan->start(SCAN_TIME);
}

// --- 7. MAIN LOOP (From Heartbeat script structure) ---
void loop() {
  if (doConnect) {
    BLEClient* pClient = BLEDevice::createClient();
    pClient->setClientCallbacks(new MyClientCallback());

    if (pClient->connect(*pServerAddress)) {
      BLERemoteService* pSvc = pClient->getService(serviceUUID);
      if (pSvc != nullptr) {
        pRemoteCharacteristic = pSvc->getCharacteristic(charUUID);
        if (pRemoteCharacteristic != nullptr && pRemoteCharacteristic->canNotify()) {
          pRemoteCharacteristic->registerForNotify(notifyCallback);
          // Connected state is handled by the Callback
        }
      }
    } else {
      doConnect = false;
    }

    if (!connected) {
      Serial.println("Connection failed. Waiting delay...");
      delay(RETRY_DELAY);
      BLEDevice::getScan()->start(SCAN_TIME);
      doScan = true;
    }
    doConnect = false;
  }

  if (connected) {
    updateLEDs();
  } else if (doScan) {
    // Pulse Blue while searching (The Heartbeat "ScanBlink" equivalent)
    uint8_t b = beatsin8(30, 20, 160);
    leds[0] = leds[1] = leds[2] = CRGB(0, 0, b);
  }
  
  FastLED.show();
  delay(20); 
}
